// Generated by CoffeeScript 2.6.1
(function() {
  // ---------------------------------------------------------------------------------------
  // Includes
  var Games, connections, discordAuth, express, fs, games, https, load, main, now, ownerLookup, pad, processAction, processOAuth, randomString, receiveView, saveDiscordAuth, saveDiscordAuthNeeded, saveIfNeeded, saveViews, saveViewsNeeded, secrets, serverEpoch, viewAddPlayer, viewAddSpectator, viewBroadcast, viewDisconnect, viewNew, viewRemoveSocket, views;

  express = require('express');

  fs = require('fs');

  https = require('https');

  Games = require('./Games');

  // ---------------------------------------------------------------------------------------
  // Helpers
  now = function() {
    return Math.floor(Date.now() / 1000);
  };

  pad = function(s, count) {
    return ("                   " + s).slice(-1 * count);
  };

  randomString = function() {
    return Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15);
  };

  // ---------------------------------------------------------------------------------------
  // Globals
  serverEpoch = now();

  secrets = null;

  connections = {};

  ownerLookup = {}; // [tag -> vid] map, ensuring a user only has one active owned view

  views = {};

  discordAuth = {};

  games = null;

  // ---------------------------------------------------------------------------------------
  // Load / Save
  load = function() {
    var vid, view;
    if (fs.existsSync("views.json")) {
      views = JSON.parse(fs.readFileSync("views.json", 'utf8'));
      for (vid in views) {
        view = views[vid];
        ownerLookup[view.owner] = vid;
      }
    }
    if (fs.existsSync("auth.json")) {
      discordAuth = JSON.parse(fs.readFileSync("auth.json", 'utf8'));
    }
    games = new Games();
  };

  saveViewsNeeded = false;

  saveDiscordAuthNeeded = false;

  saveViews = function() {
    return saveViewsNeeded = true;
  };

  saveDiscordAuth = function() {
    return saveDiscordAuthNeeded = true;
  };

  saveIfNeeded = function() {
    if (saveViewsNeeded) {
      // TODO: REENABLE
      // fs.writeFileSync("views.json", JSON.stringify(views, null, 2))
      // console.log "Views saved."
      saveViewsNeeded = false;
    }
    if (saveDiscordAuthNeeded) {
      fs.writeFileSync("auth.json", JSON.stringify(discordAuth, null, 2));
      saveDiscordAuthNeeded = false;
    }
    // console.log "Discord auth saved."
    return games.saveIfNeeded();
  };

  // saveUserPlaylists = ->
  //   fs.writeFileSync("userplaylists.json", JSON.stringify(userPlaylists, null, 2))

  // logOutput = (pkt) ->
  //   output.push pkt
  //   while output.length > 10
  //     output.shift()
  //   return

  // refreshDashboards = ->
  //   for vid, soc of sockets
  //     soc.emit 'refresh', {}

  // requestDashboardRefresh = ->
  //   dashboardsRefreshNeeded = true

  // refreshDashboardsIfNeeded = ->
  //   if dashboardsRefreshNeeded
  //     # console.log "refreshDashboardsIfNeeded(): refreshing..."
  //     dashboardsRefreshNeeded = false
  //     refreshDashboards()

  // soloBroadcast = (sender, pkt) ->
  //   for vid, soc of sockets
  //     if vid == sender
  //       continue

  //     if soloViews[vid] == pkt.id
  //       soc.emit 'solo', pkt
  //   return

  // ---------------------------------------------------------------------------------------
  // View
  viewAddPlayer = function(view, sid, auth) {
    var ignoredSid, pid, player, ref, tag, usedPids;
    console.log(`viewAddPlayer: sid ${sid} vid ${view.vid} auth ${auth}`);
    if (view.players[sid] != null) {
      return;
    }
    usedPids = {};
    ref = view.players;
    for (ignoredSid in ref) {
      player = ref[ignoredSid];
      usedPids[player.pid] = true;
    }
    pid = 1;
    while (usedPids[pid]) {
      pid += 1;
    }
    tag = null;
    if ((auth != null) && (auth.tag != null)) {
      tag = auth.tag;
    }
    view.players[sid] = {
      pid: pid,
      tag: tag
    };
    connections[sid].vid = view.vid;
    return console.log("viewAddPlayer complete: view", view);
  };

  viewAddSpectator = function(view, sid) {
    view.spectators[sid] = true;
    connections[sid].vid = view.vid;
    return console.log("viewAddSpectator complete: view", view);
  };

  viewRemoveSocket = function(view, sid) {
    console.log(`viewRemoveSocket: sid ${sid} vid ${view.vid}`);
    if (view.players[sid] != null) {
      delete view.players[sid];
    }
    if (view.spectators[sid] != null) {
      delete view.spectators[sid];
    }
    return saveViews();
  };

  viewDisconnect = function(sid) {
    var connection, view;
    console.log(`viewDisconnect: ${sid}`);
    connection = connections[sid];
    if (connection != null) {
      if ((connection.vid != null) && (views[connection.vid] != null)) {
        view = views[connection.vid];
        viewRemoveSocket(view, sid);
        return viewBroadcast(view);
      }
    }
  };

  viewNew = function(vid, sid, auth) {
    var prevVid, view;
    if (auth == null) {
      console.error("calling viewNew without auth! Impossible!");
      process.exit(1);
    }
    view = {
      vid: vid,
      owner: auth.tag,
      players: {},
      spectators: {},
      game: null
    };
    console.log("viewNew: ", view);
    prevVid = ownerLookup[auth.tag] != null;
    if ((prevVid != null) && (views[prevVid] != null)) {
      // Cleanup this player's previously owned view
      delete views[prevVid];
    }
    views[vid] = view;
    ownerLookup[auth.tag] = view;
    saveViews();
    return view;
  };

  viewBroadcast = function(view) {
    var connection, player, ref, ref1, results, sid, spectator;
    console.log("viewBroadcast", view);
    games.updateView(view);
    ref = view.players;
    for (sid in ref) {
      player = ref[sid];
      console.log(`player ${player.pid}: ${sid}`);
      connection = connections[sid];
      if (connection != null) {
        connection.socket.emit('view', view);
      }
    }
    ref1 = view.spectators;
    results = [];
    for (sid in ref1) {
      spectator = ref1[sid];
      console.log(`spectator: ${sid}`);
      connection = connections[sid];
      if (connection != null) {
        results.push(connection.socket.emit('view', view));
      } else {
        results.push(void 0);
      }
    }
    return results;
  };

  receiveView = function(socket, pkt) {
    var auth, view;
    if (pkt.vid == null) {
      return;
    }
    auth = null;
    if ((pkt.token != null) && (discordAuth[pkt.token] != null)) {
      auth = discordAuth[pkt.token];
    }
    view = views[pkt.vid];
    if (view != null) {
      // Already have this view
      console.log("Found view:", view);
    } else if ((auth != null) && !pkt.spectator) {
      // Create a new view for this user
      view = viewNew(pkt.vid, socket.id, auth);
    } else {
      // An unknown view and the user isn't logged in to own it. Error out.
      socket.emit('errortext', {
        text: "No such view. Please login to create your own view."
      });
      return;
    }
    if (!pkt.spectator) {
      viewAddPlayer(view, socket.id, auth);
    } else {
      viewAddSpectator(view, socket.id);
    }
    return viewBroadcast(view);
  };

  processAction = function(socket, pkt) {
    var connection, player, view;
    console.log("processAction:", pkt);
    connection = connections[socket.id];
    if (connection == null) {
      console.log("no connection");
      return;
    }
    view = views[connection.vid];
    if (view == null) {
      console.log("no view");
      return;
    }
    player = view.players[socket.id];
    if (player != null) {
      games.action(view, player.pid, pkt);
      return viewBroadcast(view);
    } else {
      console.log("no player");
    }
  };

  // ---------------------------------------------------------------------------------------
  // OAuth
  processOAuth = function(code) {
    console.log(`processOAuth: ${code}`);
    return new Promise(function(resolve, reject) {
      var options, params, postdata, req;
      if ((code == null) || (code.length < 1)) {
        resolve('');
        return;
      }
      postdata = {
        client_id: secrets.discordClientID,
        client_secret: secrets.discordClientSecret,
        grant_type: 'authorization_code',
        redirect_uri: secrets.url + '/oauth',
        code: code,
        scope: 'identify'
      };
      params = String(new URLSearchParams(postdata));
      options = {
        hostname: 'discord.com',
        port: 443,
        path: '/api/oauth2/token',
        method: 'POST',
        headers: {
          'Content-Length': params.length,
          'Content-Type': 'application/x-www-form-urlencoded'
        }
      };
      req = https.request(options, function(res) {
        var rawJSON;
        rawJSON = "";
        res.on('data', function(chunk) {
          return rawJSON += chunk;
        });
        res.on('error', function() {
          console.log("Error getting auth");
          return resolve('');
        });
        return res.on('end', function() {
          var data, meOptions, meReq;
          data = null;
          try {
            data = JSON.parse(rawJSON);
          } catch (error) {
            console.log(`ERROR: Failed to talk to parse JSON: ${rawJSON}`);
            resolve('');
            return;
          }
          // console.log "Discord replied: ", JSON.stringify(data, null, 2)
          if ((data.access_token == null) || (data.access_token.length < 1) || (data.token_type == null) || (data.token_type.length < 1)) {
            console.log("bad oauth reply (no access_token or token_type):", data);
            resolve('');
            return;
          }
          meOptions = {
            hostname: 'discord.com',
            port: 443,
            path: '/api/users/@me',
            headers: {
              'Authorization': `${data.token_type} ${data.access_token}`
            }
          };
          // console.log "meOptions:", meOptions
          meReq = https.request(meOptions, function(meRes) {
            var meRawJSON;
            meRawJSON = "";
            meRes.on('data', function(chunk) {
              return meRawJSON += chunk;
            });
            meRes.on('error', function() {
              console.log("Error getting auth");
              return resolve('');
            });
            return meRes.on('end', function() {
              var meData, newToken, tag;
              meData = null;
              try {
                meData = JSON.parse(meRawJSON);
              } catch (error) {
                console.log(`ERROR: Failed to talk to parse JSON: ${meRawJSON}`);
                resolve('');
                return;
              }
              // console.log "Me replied:", meData
              if ((meData != null) && (meData.username != null) && (meData.discriminator != null)) {
                tag = `${meData.username}#${meData.discriminator}`;
                while (true) {
                  newToken = randomString();
                  if (discordAuth[newToken] == null) {
                    break;
                  }
                }
                discordAuth[newToken] = {
                  token: newToken,
                  tag: tag,
                  added: now()
                };
                console.log(`Login [${newToken}]: ${discordAuth[newToken].tag}`);
                resolve(newToken);
                return saveDiscordAuth();
              } else {
                console.log("ERROR: Giving up on new token, couldn't get username and discriminator:", meData);
                return resolve('');
              }
            });
          });
          return meReq.end();
        });
      });
      req.write(params);
      req.end();
      return console.log("sending request:", postdata);
    });
  };

  // ---------------------------------------------------------------------------------------
  // Main
  main = function(argv) {
    var app, host, http, io;
    secrets = JSON.parse(fs.readFileSync('secrets.json', 'utf8'));
    console.log("Secrets:");
    console.log(JSON.stringify(secrets, null, 2));
    load();
    if (!secrets.discordClientID || !secrets.discordClientSecret) {
      console.log("Discord settings required.");
      process.exit(1);
    }
    setInterval(function() {
      return saveIfNeeded();
    }, 5 * 1000);
    app = express();
    http = require('http').createServer(app);
    io = require('socket.io')(http, {
      pingTimeout: 10000
    });
    io.on('connection', function(socket) {
      console.log(`-----------\nCONNECT[${socket.id}]`);
      connections[socket.id] = {
        socket: socket,
        vid: null
      };
      socket.emit('server', {
        epoch: serverEpoch
      });
      socket.on('disconnect', function() {
        console.log(`DISCONNECT[${socket.id}]`);
        viewDisconnect(socket.id);
        if (connections[socket.id] != null) {
          return delete connections[socket.id];
        }
      });
      socket.on('identify', function(pkt) {
        var reply;
        if ((pkt.token != null) && (discordAuth[pkt.token] != null)) {
          reply = {
            tag: discordAuth[pkt.token].tag
          };
          socket.emit('identify', reply);
          return;
        }
        return socket.emit('identify', {});
      });
      socket.on('view', function(pkt) {
        return receiveView(socket, pkt);
      });
      return socket.on('action', function(pkt) {
        return processAction(socket, pkt);
      });
    });
    app.get('/', function(req, res) {
      var discordClientID, html, k, ref, url, v, vid;
      vid = req.query.vid;
      if (vid == null) {
        while (true) {
          vid = randomString();
          if (views[vid] == null) {
            break;
          }
        }
        url = `/?vid=${vid}`;
        ref = req.query;
        for (k in ref) {
          v = ref[k];
          url += `&${encodeURIComponent(k)}=${encodeURIComponent(v)}`;
        }
        res.redirect(url);
        return;
      }
      html = fs.readFileSync(`${__dirname}/../web/client.html`, "utf8");
      discordClientID = secrets.discordClientID;
      if (discordClientID == null) {
        discordClientID = "0";
      }
      html = html.replace(/!CLIENT_ID!/, discordClientID);
      return res.send(html);
    });
    app.get('/oauth', function(req, res) {
      if ((req.query != null) && (req.query.code != null)) {
        return processOAuth(req.query.code).then(function(token) {
          if ((token != null) && (token.length > 0)) {
            return res.redirect(`/?token=${token}`);
          } else {
            return res.redirect('/');
          }
        });
      } else {
        return res.redirect('/');
      }
    });
    app.use(express.static('web'));
    host = '127.0.0.1';
    if (argv.length > 0) {
      host = '0.0.0.0';
    }
    return http.listen(3003, host, function() {
      return console.log(`listening on ${host}:3003`);
    });
  };

  module.exports = main;

}).call(this);
